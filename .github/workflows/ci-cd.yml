name: CI/CD Pipeline - Production Hardened

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

env:
  REGISTRY: ghcr.io
  # Convert to lowercase for Docker registry compatibility
  IMAGE_NAME: ${{ github.repository_owner }}/${{ github.event.repository.name }}
  # Default deploy path (bisa override via GitHub Secret DEPLOY_PATH)
  DEPLOY_PATH: ${{ secrets.DEPLOY_PATH != '' && secrets.DEPLOY_PATH || '/opt/pbjt-library' }}

# Cancel older runs on same ref (keeps latest)
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # ===== JOB 1: STRICT TESTING =====
  test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Generate Prisma Client
        run: bunx prisma generate

      - name: Run type check
        run: bun run typecheck

      - name: Run linter
        run: bun run lint

      # Uncomment when tests exist
      # - name: Run tests
      #   run: bun test

  # ===== JOB 2: BUILD & PUSH (ONLY ON PUSH, NOT PR) =====
  build:
    if: github.event_name == 'push'
    runs-on: ubuntu-latest
    needs: test
    permissions:
      contents: read
      packages: write
    outputs:
      image-tag: ${{ steps.image.outputs.tag }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Immutable tag for deploy
      - name: Set image tag
        id: image
        run: |
          echo "tag=main-${{ github.sha }}" >> $GITHUB_OUTPUT

      # Convert repository name to lowercase for Docker registry
      - name: Prepare image name
        id: prepare
        run: |
          IMAGE_NAME_LOWER=$(echo "${{ env.IMAGE_NAME }}" | tr '[:upper:]' '[:lower:]')
          echo "image_name=$IMAGE_NAME_LOWER" >> $GITHUB_OUTPUT

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ steps.prepare.outputs.image_name }}
          tags: |
            type=sha,prefix=main-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: |
            ${{ steps.meta.outputs.tags }}
            ${{ env.REGISTRY }}/${{ steps.prepare.outputs.image_name }}:${{ steps.image.outputs.tag }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # ===== JOB 3: PRODUCTION DEPLOY =====
  deploy:
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    timeout-minutes: 15
    concurrency:
      group: production-deploy
      cancel-in-progress: false
    environment:
      name: production
      url: https://api.yourdomain.com

    steps:
      - name: Add SSH known host
        run: |
          # Validate SSH_HOST is configured
          if [ -z "${{ secrets.SSH_HOST }}" ]; then
            echo "‚ùå ERROR: SSH_HOST secret is not configured!"
            echo "Please add SSH_HOST secret in GitHub repository settings."
            echo "Expected value: 172.17.2.253"
            exit 1
          fi

          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ secrets.SSH_HOST }} >> ~/.ssh/known_hosts
          chmod 644 ~/.ssh/known_hosts
          echo "‚úÖ SSH known host added: ${{ secrets.SSH_HOST }}"

      # ===== Preflight checks =====
      - name: Validate deployment prerequisites
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT || 22 }}
          script: |
            set -e

            echo "üîç Preflight checks started..."
            DEPLOY_PATH="${{ env.DEPLOY_PATH }}"

            if [ ! -d "$DEPLOY_PATH" ]; then
              echo "‚ùå Deployment directory not found: $DEPLOY_PATH"
              exit 1
            fi

            cd "$DEPLOY_PATH"

            echo "üìù Validating docker-compose.yml..."
            if ! docker compose config > /dev/null 2>&1; then
              echo "‚ùå docker-compose.yml validation failed!"
              docker compose config
              exit 1
            fi
            echo "‚úÖ Docker Compose config valid"

            echo "üîê Checking environment variables..."
            if [ ! -f .env ]; then
              echo "‚ùå .env file not found!"
              exit 1
            fi

            REQUIRED_VARS="JWT_SECRET"
            if ! grep -q "^DATABASE_URL=" .env && ! grep -q "^DB_HOST=" .env; then
              echo "‚ùå Either DATABASE_URL or DB_* vars required!"
              exit 1
            fi
            for var in $REQUIRED_VARS; do
              if ! grep -q "^${var}=" .env; then
                echo "‚ùå Required env var missing: $var"
                exit 1
              fi
            done
            echo "‚úÖ Required env vars present (values not shown)"

            echo "üê≥ Checking Docker daemon..."
            if ! docker info > /dev/null 2>&1; then
              echo "‚ùå Docker daemon not running!"
              exit 1
            fi
            echo "‚úÖ Docker daemon running"

            echo "üíæ Checking disk space..."
            AVAILABLE=$(df "$DEPLOY_PATH" | tail -1 | awk '{print $4}')
            if [ "$AVAILABLE" -lt 2097152 ]; then
              echo "‚ö†Ô∏è Warning: Low disk space (< 2GB free)"
            else
              echo "‚úÖ Disk space sufficient"
            fi

            echo "‚úÖ All preflight checks passed!"

      # ===== Deploy step =====
      - name: Deploy to production
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT || 22 }}
          script: |
            set -e

            DEPLOY_PATH="${{ env.DEPLOY_PATH }}"
            cd "$DEPLOY_PATH"

            # Optional GHCR login (public repo can skip)
            GHCR_PAT="${{ secrets.GHCR_PAT }}"
            GHCR_USER="${{ secrets.GHCR_USERNAME != '' && secrets.GHCR_USERNAME || github.repository_owner }}"
            if [ -n "$GHCR_PAT" ]; then
              echo "üîê Logging into GHCR..."
              echo "$GHCR_PAT" | docker login ${{ env.REGISTRY }} -u "$GHCR_USER" --password-stdin
            else
              echo "‚ÑπÔ∏è Skipping GHCR login (public image or GHCR_PAT not set)"
            fi

            # Deploy immutable tag from build job
            export IMAGE_TAG="${{ needs.build.outputs.image-tag }}"
            export GITHUB_REPOSITORY="${{ github.repository }}"

            echo "üöÄ Deploying image tag: $IMAGE_TAG"

            # Capture current image/tag for rollback (no hardcoded container name)
            CID=$(docker compose ps -q backend || true)
            CURRENT_IMAGE=$(docker inspect "$CID" --format='{{.Config.Image}}' 2>/dev/null || echo "none")
            CURRENT_TAG=$(echo "$CURRENT_IMAGE" | awk -F: '{print $2}' || echo "none")
            echo "üìå Current image: $CURRENT_IMAGE"
            echo "üìå Current tag: $CURRENT_TAG"
            echo "üì¶ New tag: $IMAGE_TAG"

            echo "üì• Pulling new backend image..."
            docker compose pull backend

            # Migrations: safe mode (run only if script exists locally)
            if [ -f package.json ] && grep -q "\"db:migrate:deploy\"" package.json; then
              echo "üì¶ Running database migrations..."
              docker compose run --rm backend bun run db:migrate:deploy
            else
              echo "‚ÑπÔ∏è No db:migrate:deploy script found (or no package.json). Skipping migrations (manual for now)."
            fi

            echo "üîÑ Updating backend container..."
            docker compose up -d --no-deps backend

            echo "‚è≥ Waiting for backend to be healthy..."
            MAX_WAIT=60
            ELAPSED=0

            until curl -f http://localhost:3000/health > /dev/null 2>&1; do
              if [ $ELAPSED -ge $MAX_WAIT ]; then
                echo "‚ùå Health check timeout after ${MAX_WAIT}s!"
                echo "üìã Backend logs:"
                docker compose logs --tail=80 backend

                # Auto rollback if possible
                if [ "$CURRENT_TAG" != "none" ] && [ "$CURRENT_TAG" != "$IMAGE_TAG" ]; then
                  echo "üîÑ Rolling back to previous tag: $CURRENT_TAG"
                  export IMAGE_TAG="$CURRENT_TAG"
                  docker compose up -d --no-deps backend
                  sleep 5
                  if curl -f http://localhost:3000/health > /dev/null 2>&1; then
                    echo "‚úÖ Rollback successful - previous version restored"
                  else
                    echo "‚ùå Rollback failed - manual intervention required!"
                  fi
                fi
                exit 1
              fi

              echo "‚è±Ô∏è Waiting... ($ELAPSED/$MAX_WAIT seconds)"
              sleep 3
              ELAPSED=$((ELAPSED + 3))
            done

            echo "‚úÖ Backend is healthy!"
            echo "‚úÖ Deployment successful!"

            echo "üßπ Cleaning up old Docker images..."
            docker images ghcr.io/${{ github.repository }} --format "{{.Tag}}" | \
              grep "^main-" | \
              tail -n +6 | \
              xargs -r -I {} docker rmi ghcr.io/${{ github.repository }}:{} || true

            docker image prune -f || true

      - name: Verify deployment
        run: |
          echo "üéâ Deployment completed!"
          echo "üì¶ Image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.build.outputs.image-tag }}"
          echo "üîé Health check (server-side): curl http://127.0.0.1:3000/health"

# REQUIRED SECRETS (configure in GitHub repo Settings ‚Üí Secrets and variables ‚Üí Actions):
# - SSH_HOST          # Production server IP/domain (e.g., 172.17.2.253)
# - SSH_USER          # SSH username for deployment (e.g., deploy, ubuntu)
# - SSH_PRIVATE_KEY   # SSH private key content (entire key including headers)
# - SSH_PORT          # SSH port (optional, default: 22)
# - DEPLOY_PATH       # Deployment directory (optional, default: /opt/pbjt-library)
# - GHCR_PAT          # GitHub PAT with read:packages scope (optional for public repos)
# - GHCR_USERNAME     # GitHub username for GHCR (optional, defaults to repository owner)
