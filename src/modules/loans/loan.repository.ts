import { db } from "../../config/db";
import type { CreateLoanDTO } from "./loan.model";

export interface LoanWithDetails {
  id: string; // UUID (display as id)
  uuid: string; // Loan number like "LN001" (display as uuid)
  inventory_id: string;
  book_title: string;
  member_id: string;
  member_name: string;
  loan_date: string;
  return_date: string | null;
  condition_on_return: string | null;
  notes: string | null;
}

export const LoanRepository = {
  /**
   * Get all loans with book and member details
   */
  async findAll(): Promise<LoanWithDetails[]> {
    const result = await db`
      SELECT 
        l.uuid as id,
        l.id as uuid,
        l.inventory_id,
        bc.title as book_title,
        m.id as member_id,
        m.name as member_name,
        l.loan_date::text as loan_date,
        l.return_date::text as return_date
      FROM loans l
      JOIN book_inventory bi ON l.inventory_id = bi.id
      JOIN book_catalog bc ON bi.catalog_id = bc.id
      JOIN members m ON l.member_uuid = m.uuid
      ORDER BY l.loan_date DESC
    `;

    return result.map((row: any) => ({
      id: row.id,
      uuid: row.uuid,
      inventory_id: row.inventory_id,
      book_title: row.book_title,
      member_id: row.member_id,
      member_name: row.member_name,
      loan_date: row.loan_date,
      return_date: row.return_date,
      condition_on_return: null,
      notes: null,
    }));
  },

  /**
   * Get a single loan by ID
   */
  async findById(id: string): Promise<LoanWithDetails | null> {
    const result = await db`
      SELECT 
        l.uuid as id,
        l.id as uuid,
        l.inventory_id,
        bc.title as book_title,
        m.id as member_id,
        m.name as member_name,
        l.loan_date::text as loan_date,
        l.return_date::text as return_date
      FROM loans l
      JOIN book_inventory bi ON l.inventory_id = bi.id
      JOIN book_catalog bc ON bi.catalog_id = bc.id
      JOIN members m ON l.member_uuid = m.uuid
      WHERE l.uuid = ${id}
    `;

    if (result.length === 0) return null;

    const row = result[0];
    return {
      id: row.id,
      uuid: row.uuid,
      inventory_id: row.inventory_id,
      book_title: row.book_title,
      member_id: row.member_id,
      member_name: row.member_name,
      loan_date: row.loan_date,
      return_date: row.return_date,
      condition_on_return: null,
      notes: null,
    };
  },

  /**
   * Create a new loan
   * Uses individual queries since postgres library doesn't support template literals in transactions
   */
  async create(loan: CreateLoanDTO): Promise<string> {
    // Validate member exists and get UUID
    const member = await db`
      SELECT uuid FROM members WHERE id = ${loan.id}
    `;

    if (member.length === 0) {
      throw new Error("Member tidak ditemukan");
    }

    // Find available book from the catalog
    const availableBook = await db`
      SELECT id FROM book_inventory
      WHERE catalog_id = ${loan.catalog_id} AND status = 'available'
      LIMIT 1
    `;

    if (availableBook.length === 0) {
      throw new Error("Tidak ada buku yang tersedia untuk dipinjam");
    }

    // Calculate due date (14 days from loan date)
    const loanDate = loan.loan_date ? new Date(loan.loan_date) : new Date();
    const dueDate = new Date(loanDate);
    dueDate.setDate(dueDate.getDate() + 14);

    // Create loan record (ID will be auto-generated by the sequence)
    const newLoan = await db`
      INSERT INTO loans (inventory_id, member_uuid, loan_date, due_date)
      VALUES (
        ${availableBook[0].id},
        ${member[0].uuid},
        ${loanDate.toISOString().split('T')[0]},
        ${dueDate.toISOString().split('T')[0]}
      )
      RETURNING uuid
    `;

    // Update inventory status to loaned
    await db`
      UPDATE book_inventory
      SET status = 'loaned'
      WHERE id = ${availableBook[0].id}
    `;

    return newLoan[0].uuid;
  },

  /**
   * Return a loaned book
   */
  async returnLoan(
    loanId: string,
    conditionOnReturn?: string,
  ): Promise<void> {
    // Update loan record
    const updated = await db`
      UPDATE loans
      SET return_date = CURRENT_DATE
      WHERE uuid = ${loanId} AND return_date IS NULL
      RETURNING inventory_id
    `;

    if (updated.length === 0) {
      throw new Error("Pinjaman tidak ditemukan atau sudah dikembalikan");
    }

    // Update inventory status back to available (or damaged)
    let newStatus: string = "available";
    if (conditionOnReturn === "damaged" || conditionOnReturn === "poor") {
      newStatus = "damaged";
    }

    await db`
      UPDATE book_inventory
      SET status = ${newStatus}
      WHERE id = ${updated[0].inventory_id}
    `;
  },

  /**
   * Update loan details (not for returning books)
   */
  async updatePartial(
    loanId: string,
    data: {
      loan_date?: string;
    },
  ): Promise<void> {
    if (!data.loan_date) return;

    await db`
      UPDATE loans
      SET loan_date = ${data.loan_date}
      WHERE uuid = ${loanId} AND return_date IS NULL
    `;
  },

  /**
   * Delete a loan (use with caution)
   * Should restore inventory status if loan wasn't returned
   */
  async delete(id: string): Promise<void> {
    // Get loan details first
    const loan = await db`
      SELECT inventory_id, return_date
      FROM loans
      WHERE uuid = ${id}
    `;

    if (loan.length === 0) {
      throw new Error("Loan tidak ditemukan");
    }

    // If loan wasn't returned, restore inventory status
    if (!loan[0].return_date) {
      await db`
        UPDATE book_inventory
        SET status = 'available'
        WHERE id = ${loan[0].inventory_id}
      `;
    }

    // Delete the loan
    await db`
      DELETE FROM loans WHERE uuid = ${id}
    `;
  },
};
